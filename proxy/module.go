// Copyright 2021 Linka Cloud  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package proxy

import (
	"strings"
	"text/template"

	pgs "github.com/lyft/protoc-gen-star"
	pgsgo "github.com/lyft/protoc-gen-star/lang/go"
)

func Module() *proxy {
	return &proxy{
		ModuleBase: &pgs.ModuleBase{},
	}
}

type proxy struct {
	*pgs.ModuleBase
	ctx pgsgo.Context
	tpl *template.Template
}

func (p *proxy) Name() string {
	return "proxy"
}

func (p *proxy) InitContext(c pgs.BuildContext) {
	p.ModuleBase.InitContext(c)
	p.ctx = pgsgo.InitContext(c.Parameters())

	tpl := template.New("proxy").Funcs(map[string]interface{}{
		"package":      p.ctx.PackageName,
		"name":         p.ctx.Name,
		"serverName":   p.ctx.ServerName,
		"clientName":   p.ctx.ClientName,
		"serverStream": p.ctx.ServerStream,
		"comment": func(s string) string {
			var out string
			parts := strings.Split(s, "\n")
			for i, v := range parts {
				if i == len(parts)-1 && v == "" {
					return out
				}
				out += "//" + v + "\n"
			}
			return out
		},
	})
	p.tpl = template.Must(tpl.Parse(fieldsTpl))
}

func (p *proxy) Execute(targets map[string]pgs.File, _ map[string]pgs.Package) []pgs.Artifact {
	for _, f := range targets {
		if len(f.Services()) == 0 {
			continue
		}
		p.generate(f)
	}
	return p.Artifacts()
}

func (p *proxy) generate(f pgs.File) {
	if len(f.Messages()) == 0 {
		return
	}
	name := p.ctx.OutputPath(f).SetExt(".proxy.go")
	p.AddGeneratorTemplateFile(name.String(), p.tpl, f)
}

const fieldsTpl = `{{ comment .SyntaxSourceCodeInfo.LeadingComments }}
{{ range .SyntaxSourceCodeInfo.LeadingDetachedComments }}
{{ comment . }}
{{ end }}
// Code generated by protoc-gen-defaults. DO NOT EDIT.

package {{ package . }}

import (
	"context"

	"google.golang.org/grpc"
)

{{ range .Services }}
{{ $name := .Name }}

var _ {{ $name }}Server = (*proxy{{ $name }})(nil)

func New{{ $name }}Proxy(c {{ clientName . }}, opts ...grpc.CallOption) {{ serverName . }} {
	return &proxy{{ $name }}{c: c, opts: opts}
}

type proxy{{ $name }} struct {
	c {{ $name }}Client
	opts []grpc.CallOption
}

{{ range .Methods }}

// {{ .Name }} proxies call to backend server
{{- if and .ClientStreaming .ServerStreaming }}
func (x *proxy{{ $name }}) {{ .Name }}(s {{ serverStream . }}) error {
	cs, err := x.c.{{ .Name }}(s.Context(), x.opts...)
	if err != nil {
		return err
	}
	defer cs.CloseSend()
	errs := make(chan error, 2)
	recv := func() error {
		for {
			req, err := s.Recv()
			if err != nil {
				return err
			}
			if err := cs.Send(req); err != nil {
				return err
			}
		}
	}
	send := func() error {
		for {
			res, err := cs.Recv()
			if err != nil {
				return err
			}
			if err := s.Send(res); err != nil {
				return err
			}
		}
	}
	go func() {
		errs <- recv()
	}()
	go func() {
		errs <- send()
	}()
	return <-errs
}
{{- else if .ClientStreaming }}
func (x *proxy{{ $name }}) {{ .Name }}(s {{ serverStream . }}) error {
	cs, err := x.c.{{ .Name }}(s.Context(), x.opts...)
	if err != nil {
		return err
	}
	defer cs.CloseSend()
	for {
		r, err := s.Recv()
		if err != nil {
			return err
		}
		if err := cs.Send(r); err != nil {
			return err
		}
	}
}
{{- else if .ServerStreaming }}
func (x *proxy{{ $name }}) {{ .Name }}(req *{{ .Input.Name }}, s {{ serverStream . }}) error {
	cs, err := x.c.{{ .Name }}(s.Context(), req, x.opts...)
	if err != nil {
		return err
	}
	defer cs.CloseSend()
	for {
		res, err := cs.Recv()
		if err != nil {
			return err
		}
		if err := s.Send(res); err != nil {
			return err
		}
	}
}
{{ else }}
func (x *proxy{{ $name }}) {{ .Name }}(ctx context.Context, req *{{ .Input.Name }}) (*{{ .Output.Name }}, error) {
	return x.c.{{ .Name }}(ctx, req, x.opts...)
}
{{ end }}


{{ end }}
func (x *proxy{{ $name }}) mustEmbedUnimplemented{{ $name }}Server() {}
{{ end }}
`
